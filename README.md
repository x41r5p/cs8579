Assignment 5: Markov Chain for Procedural Level<br>Generation<br>The purpose of this assignment is to make you familiar with procedural content generation for<br>level design. Markov Chains are one of the earliest Procedural Content Generation via Machine<br>Learning (sometimes called “Generative AI”) approaches, with example applications dating back<br>to 1957, they were the first approach applied to game level models, and has been used in tools<br>for game developers. In this assignment you’ll implement a Markov Chain for level generation.<br>Specifically, in this assignment we’ll pretend that you’re the Game AI lead at a company making<br>a roguelike/procedural Pacman clone (the game you’ve been working on all term). The level<br>designer for the game wants you to create a procedural level generation system, and has given<br>you 20 levels in a tile-based representation (see below) as examples. But they’re kind of weird<br>(both the levels and the designer). Your goal is to use these 20 levels to learn a final Markov<br>Level Generator that can successfully replicate this designer’s distinct style. Notably these 20<br>levels are unique to you.<br>What’s actually happened here is that I have generated a secret Pacman Markov Chain Level<br>Generator, unique to each of you, with its own probabilities, and its own state representation.<br>This is where your 20 given levels (and several withheld test levels) come from. Your job is to<br>replicate this Markov Chain from only the given 20 output levels. I have verified this is possible<br>for all students in all cases.<br>Above you can see an example level generated for this assignment with a simple L-shaped<br>Markov Chain generator that would get 7/10 on this assignment.<br>What you need to know<br>There’s only one script. that you’ll be editing for this assignment (MarkovLevelGenerator.cs),<br>unless you go for the extra credit. You’ll also be working with a helper script. to a very minor<br>extent (TXTtoLevel.cs) and a data structure representation for Pacman levels (Level.cs). If you<br>go for the Extra Credit, it’ll be worth digging deeper into Level.cs, and one route to the extra<br>credit would benefit from taking a look at LevelOptimizer.cs. Your job will be to alter<br>MarkovLevelGenerator.cs to implement a Markov Chain and then improve that Markov<br>Chain so it can better model your specific levels.<br>Pacman Representation<br>This first bit is not a script. but the “tile” representation used in this assignment.<br>Above left is the original Pacman level (Assets > HW5 > Original Pacman Levels > Original ><br>pacman.jpg). In the middle is the “tile” representation of the level (Assets > HW5 > Original<br>Pacman Levels > Processed > pacman.txt), and to the right is the level loaded into the Unity<br>project for Assignment 5 (yes this is an intentional simplification).<br>In this “tile” representation, levels are translated into characters, with each character<br>representing a certain type of in-game cell. You can find a list of these tiles in (Assets > HW5 ><br>Original Pacman Levels > pacman.json), which I’ve also described in raw text below. You do<br>not need to understand all of these to do the assignment, they’re here as a reference.<br>● G : Ghost spawn position cell<br>● S : Player spawn position cell<br>● - : A completely empty cell (tend to be around the ghost spawn in real Pacman levels)<br>● . : A cell with a pellet in it<br>● o : A cell with a power pellet in it<br>● X : A cell with a square obstacle inside it exactly the size of the cell<br>● [ : A cell where the left side is an obstacle line<br>● ] : A cell where the right side is an obstacle line<br>● ' : A cell where the top side is an obstacle line<br>● _ : A cell where the bottom side is an obstacle line<br>● P : A cell where the top and left sides are obstacle lines<br>● R : A cell where the top and right sides are obstacle lines<br>● L : A cell where the bottom and left sides are obstacle lines<br>● D : A cell where the bottom and right sides are obstacle lines<br>● = : A cell where the top and bottom sides are obstacle lines<br>● T : A cell where the left and right sides are obstacle lines<br>● C : A cell where the top, left, and bottom sides are obstacle lines<br>● Q : A cell where the top, right, and bottom sides are obstacle lines<br>MarkovLevelGenerator.cs<br>This is the only script. you will have to edit for the assignment (unless you do the extra credit) in<br>order to implement a basic “L-shaped” Markov Chain (though more of a rotated L in this case)<br>and then to further improve that to better model your assigned levels. This generator generates<br>tile-by-tile from the top left to the bottom right.<br>Member variables:<br>● markovChain: A Dictionary with string keys (representing states) and Dictionary values<br>representing actions (AKA next tiles) as strings (key) to the probability of each action<br>represented as a float (value). You will be responsible for ensuring this variable<br>represents your final Markov Chain.<br>● MarkovChain: A public getter for markovChain<br>● nullToken: A string to represent a null tile for if we lack some state information<br>● levelChars: An array of chars representing each possible tile (see above). You can likely<br>ignore this!<br>● obstacleColours: An array of colours, used to randomly colour a generated level. Also<br>ignorable, unless you want to change your output colours for aesthetic reasons. It’s<br>largely here as an example that might be relevant to the extra credit.<br>Member functions:<br>● TrainMarkovChain (TextAsset[] levels): This is the function you will primarily be modifying<br>for this assignment. You will need to update this so it matches the pseudocode<br>provided during the lecture and given below.<br>● GenerateLevel: Queries the Markov Chain for a level in the tile representation, converts<br>it to the Level representation (below) and then sets all its obstacles to a random colour.<br>This generates levels from the top left to the bottom right.<br>● GetMarkovState(string level, int x, int y): Returns a state: currently the default L-shaped<br>state, grabbing the left, above, and left and above tiles to represent the state. You will<br>need to update this so that your Markov Chain does a better job modelling your<br>individual data.<br>TXTtoLevel.cs<br>This is just a helper script. for converting strings of levels in the tile representation to the Level<br>representation (see below).<br>Level.cs<br>This script. holds the Level class, which is the basic representation of a specific level. You will<br>not make any changes to this script. as it’s only for storing level data, but you will work with it. A<br>particular Level object will specify a particular level. You can get pretty out there with this (see<br>examples below). Both of the below are extra credit submissions from Winter 2024 that received<br>the max possible points.<br>Member public variables:<br>● pellets: A list of ProtoPellet objects that represent the pellets in this level in terms of their<br>location (Vector3 worldPosition) and whether or not it is a power pellet (bool<br>powerPellet). Your code will be changing this value in LevelOptimizer.<br>● obstacles: A list of ProtoObstacle objects that represent the obstacles in this level. For<br>the base assignment you only need to specify these in terms of their location (Vector3<br>WorldPosition) and shape (Vector2[] shape), but you have the option to impact the<br>obstacle colour (lineColor) and line width (lineWidth) as well, which may be helpful for<br>extra credit.<br>● ghostStartPos: The start positions of the ghosts for this level. It is not necessary to<br>change this value, but it may be helpful for the extra credit.<br>● pacmanStartPos: The start position of Pacman for this level. It is not necessary to<br>change this value, but you may find it helpful for certain Evaluators, and it may be helpful<br>for the extra credit.<br>● fitness: Used only for the Reduce function in LevelOptimizer, meant to store the fitness<br>for this level. You will not need to interact with this variable at all.<br>Member functions:<br>● Level: There are many constructors for Level, which basically determine how much<br>information will be specified. You do not need to use any of them in your implementation,<br>but you may find it helpful.<br>● Level Clone(): Returns a clone of this level. Useful for the Mutate function in<br>LevelOptimizer.<br>● Vector2[][] GetObstaclePoints(): Returns all of the obstacle points of this level, which can<br>be used in rendering this level. You will not need to interact with this function at all.<br>ExtraCreditLevelGenerator.cs<br>This script. is solely for the extra credit and is largely empty to start. It has only a single function<br>(GenerateLevel()) as you have a massive amount of freedom in terms of how you’d like to tackle<br>the extra credit. More on this below.<br>LevelOptimizer.cs<br>LevelOptimizer is an example of implementing a search-based approach for level generation. It<br>is only presented as an example of one incomplete route to the extra credit (not necessarily<br>the best and not necessarily one you should use).<br>Member variables:<br>● width: Half of the width of each level.<br>● height: Half of the height of each level.<br>● gridSize:The standard grid size for each level<br>● POPULATION_SIZE: A variable you could use to track the size of your population.<br>● MUTATION_RATE: A variable you could use to determine with what probability to mutate<br>a member of your population.<br>● NUM_CROSSOVERS: A variable you could use to determine how many crossovers<br>you’ll have (equivalent to how many children to produce) in each iteration.<br>● MAX_ATTEMPTS: A variable that you could use to track the max number of attempts for<br>your genetic algorithm (maximum number of generations).<br>● squareObstacle: A simple set of points that can be used to define a square obstacle<br>exactly the size of a grid cell.<br>Member functions:<br>● Level GetLevel(): The main function of this assignment, and where you could implement<br>a genetic algorithm. It takes in an evaluator and goalValue that can be used to determine<br>the quality (fitness) of a particular level. It returns the best possible level according to a<br>fitness function.<br>● float Fitness(): A basic fitness function for this assignment. Simply prefers levels made<br>up of all pellets.<br>● Level Mutate(Level level): Takes in a level object and returns a neighbour, a slightly<br>different (or mutated) level. You will have to use this function or similar code in GetLevel.<br>● Level Crossover(Level parent1, Level parent2): Takes in two levels and outputs a level<br>that is a mix or “child” of these two levels. You will have to use this function or similar<br>code in GetLevel. You may find it helpful to modify this function, though there are ways<br>to complete the assignment without doing so (though it may be helpful for the extra<br>credit).<br>● Level Sample(List population): Grabs a value from the passed in population by<br>sampling based on the different Level fitness values. You may have to use this function<br>or similar code in GetLevel. It probably should not be modified.<br>● List Reduce(List population, int populationSize, Evaluator evaluator, float<br>goalValue) Takes in a population and a populationSize and passes back a List of<br>populationSize of only the best levels in terms of their fitness. You will have to use this<br>function or similar code in GetLevel. It probably should not be modified.<br>● Level GetRandomLevel(): Generates a random level. You will likely have to use this<br>function or similar code for a search-based approac代 写program、Java/c++
程序h. You may find it helpful to modify<br>this function, but it is not necessary for this assignment (though it may be helpful for the<br>extra credit). You may want to modify this function.<br>Instructions<br>Step 1: Download the “W25 Game AI Assignment 5.zip” file from eclass, unzip it, and open it via<br>Unity. You can open it by either selecting the unzipped folder from Unity or double clicking the<br>“Game” scene.<br>Step 2: Open “Game” located inside Assets/HW5. Hit the play button. You should see the<br>“simplified” original Pacman level above.<br>Step 3: Find and remove the original Pacman level from Admin’s Level Handler component (see<br>below). Run the code again. This will cause the Level Handler to instead query the Markov<br>Chain for a level. Since there’s no Markov Chain currently the level generator will just output the<br>“default” pellet in all positions.<br>Before removal:<br>After removal:<br>Step 4 (Optional): Import your own previous GridHandler, AStarPathFinder, and Custom Ghost<br>code from the prior assignments, using the instructions from those assignments to do so. The<br>only one of these that would be relevant to the assignment is your Custom Ghost code, and<br>even then only for the extra credit.<br>Step 5: Update the TrainMarkovChain function in MarkovLevelGenerator.cs so that it correctly<br>implements the Markov Chain training psuedocode given in the lecture and below:<br>for state, action in data:<br>counts[state][action] +=1<br>stateCounts[state] +=1<br>for state, action in counts:<br>markovChain[state][action] = counts[state][action]/stateCounts[state]<br>Step 6: Swap out the levels on the MarkovLevelGenerator component of the “Markov Level<br>Generator” game object in Unity. Currently it has the 17 original Pacman levels found in Assets<br>> HW5 > Original Pacman Levels > Processed. You’ll need to replace these with the 20 levels<br>found in the folder with your Canvas name on it inside Assets > HW5 > Assignment 5 Data.<br>Step 7: Update the GetMarkovState function inside MarkovLevelGenerator.cs to better reflect<br>your assigned levels. Each level secretly was generated based on a state with 2-4 additional<br>features. The full list of all possible additional state features is given below. You can use the<br>instructor and example levels to determine if your approach for finding the correct state features<br>works.<br>● X-symmetry Value: An additional feature that adds the symmetrical tile along the x-axis<br>to the state when on the right-half of the level. So if we were in the top-right corner, it’d<br>add the tile in the top-left corner.<br>● Y-symmetry Value: Same thing as the X-symmetry Value, but along the y-axis, when<br>we’re in the lower half it’ll be set to the symmetrical tile in the upper half. So if we were<br>picking the bottom-right corner tile, it’d add the top-right corner tile.<br>● Generated Ghost Spawn: Adds a boolean feature that’s 1 if we’ve added the ghost<br>spawn and 0 otherwise.<br>● Generated Player Spawn: Same thing as Generated Ghost Spawn but for the player<br>spawn.<br>● Power Pellets Count: Appends the current count of generated power pellets to the<br>state.<br>● Y-third Counted: Covers the current “third” that we’re in, in terms of the Y-values, so<br>rows 1-4 would be 0, 5-8 would be 1, and 9-12 would be 2<br>● X-half Counted: Covers if we’re in the left (0) or right (1) side of the level (the middle<br>column counts as the right half)<br>● Tenth Unobstructed: Counts every 10 pellet (“.”) or empty (“-”) tiles, so 0-9 would be 0,<br>10-19 would be 1 and so on.<br>● Tenth Solid: Counts every 10 wall tiles, so 0-9 would be 0, 10-19 would be 1 and so on.<br>● Two Left: Adds the tile two the the left of the current position, if available.<br>● Two Up: Adds the tile two up from the current position, if available.<br>● Two Left, One Up: Same thing, but two to the left and one up, if available.<br>● One Left, Two Up: Same thing, but one left and two up, if available.<br>● Two Left, Two Up: Same thing, but two left and two up, if available.<br>Note that you can use the “Train” button to test with what probability your current Markov Chain<br>would generate your set of training levels.<br>Step 8 (Optional, Extra Credit): Optionally, you may choose to fill out the GenerateLevel<br>function of ExtraCreditLevelGenerator.cs however you like.<br>Grading<br>This homework assignment is worth 10 points. Your solution will be graded by an autograder.<br>The whole assignment is about how well your Markov Chain learns the desired level design<br>style. The point breakdown is as follows:<br>7 points: If you have correctly implemented the basic Markov Chain without any updates to the<br>state, you’ll receive 7 points. This’ll be checked by ensuring that (1) your Markov Chain can<br>generate levels, 0 otherwise, and that (2) your Markov Chain achieves at least an average 65%<br>probability of generating withheld test levels (this can be approximated by leaving out test levels<br>from the provided training levels).<br>3 points: The remaining 3 points come from improving the GetMarkovState function such that<br>your Markov Chain can accurately model your specific 20 provided levels. This will be verified<br>by your Markov Chain achieving at least an average 80% probability of generating the withheld<br>test levels.<br>If your code does not compile you will get a 0. If you use any additional “using”<br>lines/import additional libraries, your code will get a 0.<br>In addition you can receive up to 2 extra credit points on this assignment. The formula for the<br>bonus looks like this:<br>Bonus = Diversity * (Playability + Style)<br>Where Diversity, Playability, and Style. are all metrics that range from 0-1 (inclusive). They will<br>be calculated by first generating 100 levels with your Extra Credit Level Generator. However,<br>students will receive 0 extra credit points if any call to the GenerateLevel function in<br>ExtraCreditLevelGenerator.cs takes more than 30 seconds to return a level.<br>Diversity is the count of unique levels divided by 100, where unique indicates a difference in<br>either pellets, obstacles, player spawn location, or ghost spawn location.<br>Playability is the count of how many levels Pacman can reach all pellets where there are at<br>least 4 pellets divided by 100.<br>Style. is the most complicated metric, as there are two ways to achieve a perfect 1.0/1.0. Either<br>you can ensure that your output levels match the level design style. of the original Pacman levels<br>(walls of consistent shapes, lengths, and colour, horizontal symmetry, regular pellet placement,<br>ghost spawn position unchanged, pacman spawn position unchanged, consistent player<br>experience compared to the original levels) or you can produce levels entirely distinct from the<br>original Pacman levels but with a consistent “style” (different from the original for all the features<br>mentioned above). You can imagine the extra credit as a linear scale with both ends of the scale<br>worth 1 point and a fully random level receiving 0 points:<br>For the left side I will be looking to ensure that your levels match the original Pacman in terms of<br>the features stated above, with points given based on to what extent it matches. For the right<br>side, I will use the same features as above, but I will check for the consistency of the differences<br>to the original levels. Those who go for the right side should have generators that produce a<br>consistent, but entirely distinct, style. of level. You can get really creative with this, though<br>notably you cannot directly change the Pacman mechanics, outside of things like your own<br>CustomGhost, if you choose to use it. That said you can get to something that basically<br>becomes a new game. I only gave the two example output levels above that would receive a<br>perfect 1.0 on this metric but I don’t want students to replicate either of these levels (any<br>generators that do will get 0 extra credit points).<br>The Discord server icon for the next iteration of this class will be chosen from the<br>students who receive the best score on the “creative” side of this scale (as it was for the<br>current icon), and the student will be honoured at the Games Certificate Awards.<br>Hints<br>The initial 7 points of this assignment are not meant to be all that challenging. The remaining 3<br>points can be brute forced, but you can also study your given levels to help give you ideas.<br>Specifically I recommend thinking about what kind of levels would be generated if a feature was<br>or wasn’t included.<br>I have once again included instructor team and example data where I’ve “given you the<br>answers” to help with this assignment. Specifically:<br>● Arghasreee Banerjee: Her levels were generated with the inclusion of the “Generated<br>Player Spawn” and “Two Left” features.<br>● Dagmar Lofts: Their levels were generated with the “X-Symmetry Value”, “Generated<br>Ghost Spawn” and “X-half Counted” features.<br>● Emily Halina: Her levels were generated with the inclusion of the “Generated Player<br>Spawn” and “Tenth Solid” features.<br>● Jawdat Toume: Her levels were generated with the “X-half Counted” and “Two Up”<br>features.<br>● Mashfiq Shahriar Zaman: His levels were generated with the “X-Symmetry Value” and<br>“Generated Ghost Spawn” features<br>● Matthew Guzdial: His levels were generated with the “Generated Player Spawn” and<br>“One Left, Two Up” features.<br>Note that of these six examples, only one has three features. Further, note that in some cases<br>the above features may not be necessary to model to achieve a sufficient Markov Chain.<br>It might be helpful to ensure you can achieve >=75% probability of generating these levels when<br>they’re your training data if you have your Markov Chain training finished and have updated the<br>state to include the above features.<br>A reminder that the Pacman Markov Chain level generator goes from top left to bottom right as<br>opposed to the example Mario Markov Chain level generator that goes from bottom left to top<br>right.<br>By “test levels from the provided training levels” in the grading section I mean moving some of<br>your levels from the “training levels” list to the “test levels” list.<br>It’s very easy to add too many features and be unable to generate anything. I’d strongly suggest<br>checking that you can still generate levels or else you’re likely to get 0 points for the test portion<br>of the assignment.<br>You have a lot of freedom for the Extra Credit. Consider making things easier for yourself by<br>picking one of the approaches covered in the PCG lecture or taking a look at the provided<br>LevelOptimizer.cs (particularly the random level generation function) as a starting point.<br>You will probably be using a lot of Random values for this assignment if you go for the extra<br>credit option. <br>You may alter your Custom Ghost code if you attempt the extra credit and think it would be<br>beneficial. However, this is not the focus of the assignment. Be careful not to waste time on this!<br>Submission<br>To submit your solution, upload your modified MarkovChainLevelGenerator.cs file. If you<br>attempted the extra credit, also upload your ExtraCreditLevelGenerator.cs file. If you made use<br>of your own GridHandler.cs, you should submit that as well. If you went for the extra credit and<br>you believe it’s necessary for your implementation, you may upload your AStarPathFinder and<br>your code from Assignment 4 (the custom ghost code).<br>You should not modify or upload any other files in the game engine. You should not import any<br>additional libraries.<br>DO NOT upload the entire game engine.<br><br><br>加QQ：99515681  WX：codinghelp  Email: 99515681@qq.com
